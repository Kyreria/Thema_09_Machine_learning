---
title: "Thema 09 Machine learning log"
author: "Dennis Haandrikman"
date: 27/09/2022
output:
    pdf_document:
        toc: true
        toc_depth: 3
---

```{r setup, include = FALSE}
# Knit options/settings
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)

# Required libraries
library("pander")
library("ggplot2")
library("dplyr")
library("ggpubr")
```
\newpage
# Introduction

In modern day science, machine learning is playing a more crucial step by the year, allowing predictions of topics which would take years to discover with the help of experiments. However, a caveat to this is, that the prediction is only as good as the submitted data and the programmer who coded the algorythm for machine learning.

As such it is important for one to understand what one can do with the data they've received and that they know the background of the data itself. As such it is important to garner background information about the data and to explore what's possible with the received data by the help of an EDA.


## Exploring the background of the data

It would be important to explore what the meaning and use for each data variable is before we start working with the data.

First off we'll discuss what the origin of the data files is, the paper that this dataset was used in, references [IEDB](http://tools.iedb.org/bcell/help/)(http://tools.iedb.org/bcell/help/) as the main source for the peptide sequences, due to the website containing information about if an amino acid peptide exhibited anti-body inducing activty, which was marked as the target label.
So both the bcel & sars peptide data have been sourced from IEDB, with the protein properties being filled in with help of the Uniprot website.
The covid peptide/protein data has been calculated with help of the same websites, except for that these haven't been labelled by IEDB.

So in the data-files the following columns are available and will be explained below:

1. parent_protein_id; This is the parent protein ID, with which it can be found on Uniprot. It's a string containing a protein ID.
2. protein_seq; This is the protein sequence of the full protein the peptide belongs to. It's a string that consists of amino acids.
3. start_position; This is the starting position of the peptide in correspondence to the full protein sequence given in protein_seq. It's an integer.
4. end_position; This is the ending position of the peptide in correspondence to the full protein sequence given in protein_seq. It's an integer.
5. peptide_seq; This is the peptide sequence that is to be analyzed. It's a string containing amino acids.
6. chou_fasman; This is a calculated peptide feature by the IEDB website, it predicts if there is a ÃŸ turn in the peptide. It's a double.
7. emini; This is a calculated peptide feature by the IEDB website, it calculates how much relative surface accessibility is available on the peptide. It's a double
8. kolaskar_tongaonkar; This is a calculated peptide prediction by the IEDB website in how antigenic the peptide is. It's a double.
9. parker; This is a calculated peptide feature by the IEDB website in how hydrophobic the peptide is. It's a double.
10. isoelectric_point; This is the calculated pH at which the charge of the protein is zero. It's a double.
11. aromacity; This is a calculated protein feature in how many aromatic connections there are in the protein. It's a double.
12. hydrophobicity; This is a calculated protein feature in how hydrophobic the complete protein is. It's a double.
13. stability; This is a calculated protein feature that refers to the energy difference between the folded and unfolded state of the protein. It's a double.

\newpage
## Importing the data

#### 15/09/2022, 16/09/2022, 20/09/2022


After acquiring the data from the database, import the data to see if there were any inconsistencies.

```{r import_data}
# Make sure the working directory is the main folder containing all the folders (project folder).
# Get the data files and import them.
bcel_data <- tibble(read.csv("./Data/input_bcell.csv", header = TRUE))
sars_data <- tibble(read.csv("./Data/input_sars.csv", header = TRUE))
covid_data <- tibble(read.csv("./Data/input_covid.csv", header = TRUE))

# print a quick head for the tables to see if it imported properly.
# Due to protein seq being such a lengthy tab, excluding from the head to make the head show able.
# In each dataset, the protein seq is the second column.
pander(head(bcel_data[-2]))
pander(head(sars_data[-2]))
pander(head(covid_data[-2]))
# here's the max length of a protein sequence to showcase why it was excluded from the head
max(nchar(bcel_data[2,]))
```

As we can see the information has been imported correctly.
However, it is of importance to check for any NA values in the information.
As such, an is.na() check will be performed on the data

```{r na_check}
# Using any(is.na(x)) showcases in true/false if there are any NA values.
any(is.na(bcel_data))
any(is.na(sars_data))
any(is.na(covid_data))
```
As we can see there aren't any missing values whatsoever in the datasets, as such we can continue to the actual EDA after we check the value-types each column has

```{r}
# Information for the bcel_data dataset
str(bcel_data)

# Information for the sars_data dataset
str(sars_data)

#Information for the covid_data dataset
str(covid_data)
```

We can see that the covid_data dataset doesn't contain the target column at the end of the dataset, this is to be expected as the original use of the dataset was to calculate the target values for the covid_data.
Next to that we can see that all the information has been loaded in properly.

However, due to the b-cell & sars datasets were both used for the same use; training the model and contain the exact same columns, it would be wise to merge the 2 datasets in 1 so that it's easier to manage the data from the 2 sets.

```{r combining_datasets}
#combining the 2 datasets with use of rbind
bcel_sars <- rbind(bcel_data,sars_data)
# To see if the binding went properly, we're calling going to calculate the length of the dataframes before and after.
# Calculating the supposed combined length of the new dataset
print(paste("The number of columns we're expecting is: ", nrow(bcel_data) + nrow(sars_data)))
print(paste("The number of columns that the new dataset contains: ", nrow(bcel_sars)))

```

As we can see above is that combining the 2 datasets was successful and no columns have been lost.

At the very end of the data import and clean-up, it would be wise to convert target column in the dataset from an integer to a factor. This is so we can differentiate between the non-antibody promoting sequences and antibody promoting sequences.
```{r factoring_target}
bcel_sars$target <- factor(bcel_sars$target, labels = c("Non-promoting", "Promoting"))

pander(data.frame(Before=bcel_data[5:15,14], After=bcel_sars[5:15,14]))
```
As we can see from the quick splice in the dataframe above, the value of 0 has been converted to Non-promoting and the value of 1 has been converted to Promoting. This has been completed as expected.


## EDA exploration

#### 20/09/2022, 23/09/2022, 25/09/2022, 26/09/2022


Now that we've made sure all the datasets have been imported properly and there are no missing values in the datasets, it was time to perform an EDA exploration.

Since the datasets all go over the properties of the peptide/proteins, a codebook was set up with information on all the properties.

```{r code_book_import}
code_book <- tibble(read.csv("peptide_protein_properties_codebook.csv", header=TRUE,sep=","))

pander(head(code_book))
```

As we can see the code-book has been imported properly, the NA's in unit have been input correctly as there is no unit for those values.


A summary for the data would be nice to oversee, however, not all the columns would be crucial to undergo a summary, for example the sequence ID, peptide ID, sequence can be omitted due to not being measurable data. As such the summary has only been performed on the protein characteristics.

```{r summary}
#Summary of the Bcel-data for the peptide/protein properties
pander(summary(bcel_sars[6:13]))
```

Based on the summary data, it shows that we can't plot the peptide properties in a singular box-plot, also due to them being different scales which have no underlying correlation to each other and are all mathematical predictions.
So to check for outliers it would be better to do single boxplots for each of them, due to their differing values/scale-range.

The protein properties would be interesting to see if there is any correlation as they are all physical properties of the molecule itself, but due to the differing value-ranges, it isn't possible to include these in a single boxplot, as such, all the peptide & protein

For ease of use later on, the protein properties will be grouped with the help of a single variable.

```{r clustering_variables}
#Cluster the variables for the protein properties
peptide_data <-(6:9)
protein_data <- (10:13)

# Testing to see if the selections grab the proper data from the datasets.
pander(head(bcel_sars[,peptide_data]))
pander(head(bcel_sars[,protein_data]))
```

AS we can see the peptide and protein have both been called properly. We can also directly see that the values have different ranges.

As follows we'll perform boxplots on each value to make sure 

```{r boxplots, fig.height=10, fig.cap="boxplots of features"}
# Setup a function to repeatably make the boxplots for the columns
boxplotfun <- function(col_name) {
  ggplot(bcel_sars, aes(x=target, y=!!sym(col_name), fill=target)) + geom_boxplot() +
    theme(plot.title = element_text(size=8), axis.title = element_text(size=8), axis.text = element_text(size=8)) +
    ylab(filter(code_book, Name == col_name)$Label) +
    xlab(NULL) +
    ggtitle(filter(code_book, Name == col_name)$Full.name)
}
# Save the column names to a list for the function
property_names <- c("chou_fasman", "emini", "kolaskar_tongaonkar", "parker", "isoelectric_point", "aromaticity", "hydrophobicity", "stability")
# Run the column names through the plot function and catch the plots in a list
plot_finished <- lapply(property_names, boxplotfun)
# Arrange the plots in a neat grid
ggarrange(plotlist = plot_finished, ncol = 2, nrow=4, common.legend = TRUE, legend = "bottom")
```

Comparing the target values (non-promoting and promoting) with each other, an interesting observation can be made that there isn't much difference at first glance between the non-promoting and promoting peptide sequences. It would be interesting to see where the differences do lie.
\newpage

First of all a histogram will be made about the Emini surface accessibility scale to get a better view at how bad the outliers stretch outbound due to the the boxplot being unreadeable.

```{r histogram_emini}
# Make the histogram plot for the emini data
ggplot(bcel_sars, aes(x=emini, fill=target)) + geom_histogram(binwidth=.5) +
  theme(plot.title = element_text(size=8), axis.title = element_text(size=8), axis.text = element_text(size=8)) +
  ylab(filter(code_book, Name == "emini")$Label) +
  xlab("Emini value") +
  ggtitle(filter(code_book, Name == "emini")$Full.name)
```

As we can see from the the histogram of the Emini surface accessibility scale, the histogram isn't neatly distributed and heavily leans to the left, confirming with the boxplot that there are outliers in the data that should be removed.


```{r log transformation}

```

An interesting second observation is that the there are more peptides that are non-promoting than promoting.

```{r outlier_removal_emini}

# Calculate the quartiles and the interquartile range
quartiles <- quantile(bcel_sars$emini, probs = c(0.25, 0.75), na.rm=FALSE)
IQR <- IQR(bcel_sars$emini)

# Calculate the upper quantile limit
Upper <- quartiles[2] + 1.5*IQR

#Remove any outlier above the upper quartile limit
bcel_sars_no_outlier <- subset(bcel_sars, bcel_sars$emini < Upper)
before <- dim(bcel_sars)
after <- dim(bcel_sars_no_outlier)

# Print the deleted amount of outliers.
print(paste("The amount of removed outliers is: ", before[1] - after[1], "outliers"))

#Get the variables out of the memory
remove(quartiles)
remove(IQR)
remove(Upper)
remove(before)
remove(after)

```

The outliers that were removed are those above the upper quartile limit.
After removing the outliers, it would be wise to print the emini histogram again, to see if this has improved the plot and if there is still a left-leaning histogram.

```{r no_outlier_hist_emini}
ggplot(bcel_sars_no_outlier, aes(x=emini, fill=target)) + geom_histogram(binwidth=.1) +
  theme(plot.title = element_text(size=8), axis.title = element_text(size=8), axis.text = element_text(size=8)) +
  ylab(filter(code_book, Name == "emini")$Label) +
  xlab("Emini value") +
  ggtitle(filter(code_book, Name == "emini")$Full.name)

```


In the figure above we can once again see the histogram plot of the emini scale, however, this is the dataset with the removed outliers. As we can see the histogram is still heavily leaning to the left and it still shows that there are a lot more non-promoting than promoting peptides.


```{r boxplots_withou_outliers, fig.height=10, fig.cap="boxplots of features without outliers"}
# Setup a function to repeatably make the boxplots for the columns
boxplotfun <- function(col_name) {
  ggplot(bcel_sars_no_outlier, aes(x=target, y=!!sym(col_name), fill=target)) + geom_boxplot() +
    theme(plot.title = element_text(size=8), axis.title = element_text(size=8), axis.text = element_text(size=8)) +
    ylab(filter(code_book, Name == col_name)$Label) +
    xlab(NULL) +
    ggtitle(filter(code_book, Name == col_name)$Full.name)
}
# Save the column names to a list for the function
property_names <- c("chou_fasman", "emini", "kolaskar_tongaonkar", "parker", "isoelectric_point", "aromaticity", "hydrophobicity", "stability")
# Run the column names through the plot function and catch the plots in a list
plot_finished <- lapply(property_names, boxplotfun)
# Arrange the plots in a neat grid
ggarrange(plotlist = plot_finished, ncol = 2, nrow=4, common.legend = TRUE, legend = "bottom")
```

In the figure above we've replotted the boxplots to see if there is any difference that we can see due to the removal of the 1307 outliers. What we can see is that the emini boxplot has become read able, although there is no noticeable difference in the other boxplots due to the removal of 1307 outliers.
After we've removed the outliers and checked if this would influence the other boxplots, it would be interesting to see if the peptide property scales have any correlation between each other. 

```{r scatterplot_peptide}
ggplot()
```




